#!/usr/bin/env bash

# ==============================================================================
# Backup system for macOS hardening script
# ==============================================================================

# Generate rollback script
generate_rollback_script() {
    local backup_dir="$1"
    local timestamp="$2"
    
    if [[ -z "$backup_dir" || -z "$timestamp" ]]; then
        error "Backup directory and timestamp are required"
        return 1
    fi
    
    local rollback_script="$backup_dir/rollback_hardening_$timestamp.sh"
    
    cat > "$rollback_script" <<'ROLL'
#!/usr/bin/env bash
# Rollback script generated by mac_hardening
set -euo pipefail

BACKUP_DIR="$(dirname "${BASH_SOURCE[0]}")"

echo "Starting rollback from $BACKUP_DIR"

# Restore plist files
find "$BACKUP_DIR" -name "*.plist" | while read -r plist; do
    filename=$(basename "$plist")

    if [[ "$filename" == "com.apple."* ]]; then
        target_dir="/Library/Preferences"
    else
        target_dir="$HOME/Library/Preferences"
    fi

    mkdir -p "$target_dir"

    echo "Restoring $filename to $target_dir"
    cp "$plist" "$target_dir/" 2>/dev/null || echo "Failed to restore $filename"
done

# Restore other configuration files
if [[ -f "$BACKUP_DIR/etc/security/audit_control" ]]; then
    echo "Restoring audit_control"
    cp "$BACKUP_DIR/etc/security/audit_control" "/etc/security/audit_control" 2>/dev/null || true
fi

if [[ -f "$BACKUP_DIR/etc/sudoers" ]]; then
    echo "Validating sudoers file before restore"

    if visudo -c -f "$BACKUP_DIR/etc/sudoers"; then
        echo "Sudoers file valid — restoring"
        cp "$BACKUP_DIR/etc/sudoers" "/etc/sudoers"
        chmod 0440 /etc/sudoers
    else
        echo "ERROR: Backup sudoers file is invalid — restore aborted"
    fi
fi

# Remove timeout sudoers file if it exists
rm -f /etc/sudoers.d/timeout 2>/dev/null || true

# Restart affected services
launchctl unload /System/Library/LaunchDaemons/com.apple.auditd.plist 2>/dev/null || true
launchctl load /System/Library/LaunchDaemons/com.apple.auditd.plist 2>/dev/null || true

killall SystemUIServer 2>/dev/null || true
killall Finder 2>/dev/null || true

echo "Rollback completed. Some changes may require a reboot to take full effect."
echo "Please review system settings manually to ensure proper restoration."
ROLL
    
    chmod +x "$rollback_script"
    info "Rollback helper saved: $rollback_script"
}

# Create backup of a file
backup_file_to_dir() {
    local file="$1"
    local backup_dir="$2"
    
    if [[ ! -f "$file" ]]; then
        debug "File does not exist, skipping backup: $file"
        return 0
    fi
    
    if [[ "$DRY_RUN" == true ]]; then
        debug "[DRY-RUN] Would backup: $file"
        return 0
    fi
    
    local backup_path="$backup_dir$(dirname "$file")"
    execute "mkdir -p '$backup_path'"
    execute "cp -p '$file' '$backup_path/'"
    debug "Backed up to dir: $file"
}

# Clean up old backups
cleanup_old_backups_in_dir() {
    local backup_root="$1"
    local retention_days="$2"
    
    if [[ -d "$backup_root" ]]; then
        find "$backup_root" -type d -name "backup_*" -mtime +$retention_days -exec rm -rf {} \; 2>/dev/null || true
        info "Old backups cleaned up in $backup_root (older than $retention_days days)"
    fi
}

# Check available disk space
check_disk_space() {
    local backup_dir="$1"
    local required_space_mb="$2"
    
    if [[ -d "$backup_dir" ]]; then
        local available_space=$(df "$backup_dir" | awk 'NR==2 {print $4}')
        local available_mb=$((available_space / 1024))
        
        if [[ $available_mb -lt $required_space_mb ]]; then
            warn "Insufficient disk space: $available_mb MB available, $required_space_mb MB required"
            return 1
        fi
    fi
    
    return 0
}

# Create compressed archive of backup
compress_backup() {
    local backup_dir="$1"
    local archive_name="$2"
    
    if [[ "$BACKUP_COMPRESSION" == true ]]; then
        local archive_path="$backup_dir/../$archive_name.tar.gz"
        execute "tar -czf '$archive_path' -C '$backup_dir' ."
        info "Backup compressed: $archive_path"
    fi
}

# Restore from backup
restore_from_backup() {
    local backup_dir="$1"
    local file="$2"
    
    if [[ -f "$backup_dir$file" ]]; then
        execute "cp -p '$backup_dir$file' '$file'"
        success "Restored: $file"
        return 0
    else
        warn "Backup not found: $backup_dir$file"
        return 1
    fi
}

# List available backups
list_backups() {
    local backup_root="$1"
    
    if [[ -d "$backup_root" ]]; then
        echo "Available backups:"
        find "$backup_root" -type d -name "backup_*" | sort -r | head -10
    else
        warn "No backup directory found: $backup_root"
    fi
}

# Verify backup integrity
verify_backup() {
    local backup_dir="$1"
    
    if [[ ! -d "$backup_dir" ]]; then
        error "Backup directory not found: $backup_dir"
        return 1
    fi
    
    local backup_files=$(find "$backup_dir" -type f | wc -l)
    info "Backup contains $backup_files files"
    
    # Check critical files
    local critical_files=(
        "/Library/Preferences/com.apple.loginwindow.plist"
        "/etc/security/audit_control"
        "/etc/sudoers"
    )
    
    for file in "${critical_files[@]}"; do
        if [[ -f "$backup_dir$file" ]]; then
            success "✓ Critical file backed up: $file"
        else
            warn "✗ Critical file missing: $file"
        fi
    done
}
